@startuml
namespace cgi {
    class Handler << (S,Aquamarine) >> {
        + Path string
        + Root string
        + Dir string
        + Env []string
        + InheritEnv []string
        + Logger *log.Logger
        + Args []string
        + Stderr io.Writer
        + PathLocationHandler http.Handler

        + ServeHTTP(rw http.ResponseWriter, req *http.Request) 

    }
    class response << (S,Aquamarine) >> {
        + Flush() 
        + Header() http.Header
        + Write(p []byte) (int, error)
        + WriteHeader(code int) 

    }
}

"http.Handler" <|-- "cgi.Handler"
"http.Flusher" <|-- "cgi.response"
"http.ResponseWriter" <|-- "cgi.response"

namespace cookiejar {
    class Jar << (S,Aquamarine) >> {
        + Cookies(u *url.URL) []*http.Cookie
        + SetCookies(u *url.URL, cookies []*http.Cookie) 

    }
    class Options << (S,Aquamarine) >> {
        + PublicSuffixList PublicSuffixList

    }
    interface PublicSuffixList  {
        + PublicSuffix(domain string) string
        + String() string

    }
    class entry << (S,Aquamarine) >> {
        + Name string
        + Value string
        + Domain string
        + Path string
        + SameSite string
        + Secure bool
        + HttpOnly bool
        + Persistent bool
        + HostOnly bool
        + Expires time.Time
        + Creation time.Time
        + LastAccess time.Time

    }
}

"http.CookieJar" <|-- "cookiejar.Jar"

namespace fcgi {
    class beginRequest << (S,Aquamarine) >> {
    }
    class bufWriter << (S,Aquamarine) >> {
        + Close() error

    }
    class child << (S,Aquamarine) >> {
    }
    class conn << (S,Aquamarine) >> {
        + Close() error

    }
    class envVarsContextKey << (S,Aquamarine) >> {
    }
    class fcgi.recType << (T, #FF7700) >>  {
    }
    class header << (S,Aquamarine) >> {
        + Version uint8
        + Type recType
        + Id uint16
        + ContentLength uint16
        + PaddingLength uint8
        + Reserved uint8

    }
    class record << (S,Aquamarine) >> {
    }
    class request << (S,Aquamarine) >> {
    }
    class response << (S,Aquamarine) >> {
        + Header() http.Header
        + Write(p []byte) (int, error)
        + WriteHeader(code int) 
        + Flush() 
        + Close() error

    }
    class streamWriter << (S,Aquamarine) >> {
        + Write(p []byte) (int, error)
        + Close() error

    }
}
"bufio.Writer" *-- "fcgi.bufWriter"

"http.Flusher" <|-- "fcgi.response"
"http.ResponseWriter" <|-- "fcgi.response"

namespace http {
    class Client << (S,Aquamarine) >> {
        + Transport RoundTripper
        + CheckRedirect <font color=blue>func</font>(*Request, []*Request) error
        + Jar CookieJar
        + Timeout time.Duration

        + Get(url string) (*Response, error)
        + Do(req *Request) (*Response, error)
        + Post(url string, contentType string, body io.Reader) (*Response, error)
        + PostForm(url string, data url.Values) (*Response, error)
        + Head(url string) (*Response, error)
        + CloseIdleConnections() 

    }
    interface CloseNotifier  {
        + CloseNotify() <font color=blue>chan</font> bool

    }
    class ConnState << (S,Aquamarine) >> {
        + String() string

    }
    class Cookie << (S,Aquamarine) >> {
        + Name string
        + Value string
        + Path string
        + Domain string
        + Expires time.Time
        + RawExpires string
        + MaxAge int
        + Secure bool
        + HttpOnly bool
        + SameSite SameSite
        + Raw string
        + Unparsed []string

        + String() string
        + Valid() error

    }
    interface CookieJar  {
        + SetCookies(u *url.URL, cookies []*Cookie) 
        + Cookies(u *url.URL) []*Cookie

    }
    class Dir << (S,Aquamarine) >> {
        + Open(name string) (File, error)

    }
    interface File  {
        + Readdir(count int) ([]fs.FileInfo, error)
        + Stat() (fs.FileInfo, error)

    }
    interface FileSystem  {
        + Open(name string) (File, error)

    }
    interface Flusher  {
        + Flush() 

    }
    interface Handler  {
        + ServeHTTP( ResponseWriter,  *Request) 

    }
    class HandlerFunc << (S,Aquamarine) >> {
        + ServeHTTP(w ResponseWriter, r *Request) 

    }
    class Header << (S,Aquamarine) >> {
        + Add(key string, value string) 
        + Set(key string, value string) 
        + Get(key string) string
        + Values(key string) []string
        + Del(key string) 
        + Write(w io.Writer) error
        + Clone() Header
        + WriteSubset(w io.Writer, exclude <font color=blue>map</font>[string]bool) error

    }
    interface Hijacker  {
        + Hijack() (net.Conn, *bufio.ReadWriter, error)

    }
    class ProtocolError << (S,Aquamarine) >> {
        + ErrorString string

        + Error() string

    }
    class PushOptions << (S,Aquamarine) >> {
        + Method string
        + Header Header

    }
    interface Pusher  {
        + Push(target string, opts *PushOptions) error

    }
    class Request << (S,Aquamarine) >> {
        + Method string
        + URL *url.URL
        + Proto string
        + ProtoMajor int
        + ProtoMinor int
        + Header Header
        + Body io.ReadCloser
        + GetBody <font color=blue>func</font>() (io.ReadCloser, error)
        + ContentLength int64
        + TransferEncoding []string
        + Close bool
        + Host string
        + Form url.Values
        + PostForm url.Values
        + MultipartForm *multipart.Form
        + Trailer Header
        + RemoteAddr string
        + RequestURI string
        + TLS *tls.ConnectionState
        + Cancel <font color=blue>chan</font> <font color=blue>struct</font>{}
        + Response *Response

        + Context() context.Context
        + WithContext(ctx context.Context) *Request
        + Clone(ctx context.Context) *Request
        + ProtoAtLeast(major int, minor int) bool
        + UserAgent() string
        + Cookies() []*Cookie
        + Cookie(name string) (*Cookie, error)
        + AddCookie(c *Cookie) 
        + Referer() string
        + MultipartReader() (*multipart.Reader, error)
        + Write(w io.Writer) error
        + WriteProxy(w io.Writer) error
        + BasicAuth() (string, string, bool)
        + SetBasicAuth(username string, password string) 
        + ParseForm() error
        + ParseMultipartForm(maxMemory int64) error
        + FormValue(key string) string
        + PostFormValue(key string) string
        + FormFile(key string) (multipart.File, *multipart.FileHeader, error)

    }
    class Response << (S,Aquamarine) >> {
        + Status string
        + StatusCode int
        + Proto string
        + ProtoMajor int
        + ProtoMinor int
        + Header Header
        + Body io.ReadCloser
        + ContentLength int64
        + TransferEncoding []string
        + Close bool
        + Uncompressed bool
        + Trailer Header
        + Request *Request
        + TLS *tls.ConnectionState

        + Cookies() []*Cookie
        + Location() (*url.URL, error)
        + ProtoAtLeast(major int, minor int) bool
        + Write(w io.Writer) error

    }
    interface ResponseWriter  {
        + Header() Header
        + Write( []byte) (int, error)
        + WriteHeader(statusCode int) 

    }
    interface RoundTripper  {
        + RoundTrip( *Request) (*Response, error)

    }
    class ServeMux << (S,Aquamarine) >> {
        + Handler(r *Request) (Handler, string)
        + ServeHTTP(w ResponseWriter, r *Request) 
        + Handle(pattern string, handler Handler) 
        + HandleFunc(pattern string, handler <font color=blue>func</font>(ResponseWriter, *Request) ) 

    }
    class Server << (S,Aquamarine) >> {
        + Addr string
        + Handler Handler
        + TLSConfig *tls.Config
        + ReadTimeout time.Duration
        + ReadHeaderTimeout time.Duration
        + WriteTimeout time.Duration
        + IdleTimeout time.Duration
        + MaxHeaderBytes int
        + TLSNextProto <font color=blue>map</font>[string]<font color=blue>func</font>(*Server, *tls.Conn, Handler) 
        + ConnState <font color=blue>func</font>(net.Conn, ConnState) 
        + ErrorLog *log.Logger
        + BaseContext <font color=blue>func</font>(net.Listener) context.Context
        + ConnContext <font color=blue>func</font>(context.Context, net.Conn) context.Context

        + Close() error
        + Shutdown(ctx context.Context) error
        + RegisterOnShutdown(f <font color=blue>func</font>() ) 
        + ListenAndServe() error
        + Serve(l net.Listener) error
        + ServeTLS(l net.Listener, certFile string, keyFile string) error
        + SetKeepAlivesEnabled(v bool) 
        + ListenAndServeTLS(certFile string, keyFile string) error

    }
    class Transport << (S,Aquamarine) >> {
        + Proxy <font color=blue>func</font>(*Request) (*url.URL, error)
        + DialContext <font color=blue>func</font>(context.Context, string, string) (net.Conn, error)
        + Dial <font color=blue>func</font>(string, string) (net.Conn, error)
        + DialTLSContext <font color=blue>func</font>(context.Context, string, string) (net.Conn, error)
        + DialTLS <font color=blue>func</font>(string, string) (net.Conn, error)
        + TLSClientConfig *tls.Config
        + TLSHandshakeTimeout time.Duration
        + DisableKeepAlives bool
        + DisableCompression bool
        + MaxIdleConns int
        + MaxIdleConnsPerHost int
        + MaxConnsPerHost int
        + IdleConnTimeout time.Duration
        + ResponseHeaderTimeout time.Duration
        + ExpectContinueTimeout time.Duration
        + TLSNextProto <font color=blue>map</font>[string]<font color=blue>func</font>(string, *tls.Conn) RoundTripper
        + ProxyConnectHeader Header
        + GetProxyConnectHeader <font color=blue>func</font>(context.Context, *url.URL, string) (Header, error)
        + MaxResponseHeaderBytes int64
        + WriteBufferSize int
        + ReadBufferSize int
        + ForceAttemptHTTP2 bool

        + RoundTrip(req *Request) (*Response, error)
        + RoundTrip(req *Request) (*Response, error)
        + Clone() *Transport
        + RegisterProtocol(scheme string, rt RoundTripper) 
        + CloseIdleConnections() 
        + CancelRequest(req *Request) 

    }
    interface anyDirs  {
    }
    class arrayReader << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)
        + Close() error

    }
    class atomicBool << (S,Aquamarine) >> {
    }
    class body << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)
        + Close() error

    }
    class bodyEOFSignal << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)
        + Close() error

    }
    class bodyLocked << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)

    }
    class bufioFlushWriter << (S,Aquamarine) >> {
        + Write(p []byte) (int, error)

    }
    class byteReader << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)

    }
    class cancelKey << (S,Aquamarine) >> {
    }
    class cancelTimerBody << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)
        + Close() error

    }
    class checkConnErrorWriter << (S,Aquamarine) >> {
        + Write(p []byte) (int, error)

    }
    class chunkWriter << (S,Aquamarine) >> {
        + Write(p []byte) (int, error)

    }
    interface closeWriter  {
        + CloseWrite() error

    }
    class conn << (S,Aquamarine) >> {
    }
    class connLRU << (S,Aquamarine) >> {
    }
    class connReader << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)

    }
    class connectMethod << (S,Aquamarine) >> {
        + _ incomparable

    }
    class connectMethodKey << (S,Aquamarine) >> {
        + String() string

    }
    class contextKey << (S,Aquamarine) >> {
        + String() string

    }
    class countingWriter << (S,Aquamarine) >> {
        + Write(p []byte) (int, error)

    }
    class dirEntryDirs << (S,Aquamarine) >> {
    }
    interface erringRoundTripper  {
        + RoundTripErr() error

    }
    class errorReader << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)

    }
    class exactSig << (S,Aquamarine) >> {
    }
    class expectContinueReader << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)
        + Close() error

    }
    class extraHeader << (S,Aquamarine) >> {
        + Write(w *bufio.Writer) 

    }
    class fakeLocker << (S,Aquamarine) >> {
        + Lock() 
        + Unlock() 

    }
    class fileHandler << (S,Aquamarine) >> {
        + ServeHTTP(w ResponseWriter, r *Request) 

    }
    class fileInfoDirs << (S,Aquamarine) >> {
    }
    class fileTransport << (S,Aquamarine) >> {
        + RoundTrip(req *Request) (*Response, error)

    }
    class finishAsyncByteRead << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)

    }
    class globalOptionsHandler << (S,Aquamarine) >> {
        + ServeHTTP(w ResponseWriter, r *Request) 

    }
    class gzipReader << (S,Aquamarine) >> {
        + _ incomparable

        + Read(p []byte) (int, error)
        + Close() error

    }
    interface h2Transport  {
        + CloseIdleConnections() 

    }
    class headerSorter << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool

    }
    class htmlSig << (S,Aquamarine) >> {
    }
    class http.ConnState << (T, #FF7700) >>  {
    }
    class http.Dir << (T, #FF7700) >>  {
    }
    class http.HandlerFunc << (T, #FF7700) >>  {
    }
    class http.Header << (T, #FF7700) >>  {
    }
    class http.SameSite << (T, #FF7700) >>  {
    }
    class http.atomicBool << (T, #FF7700) >>  {
    }
    class http.condResult << (T, #FF7700) >>  {
    }
    class http.countingWriter << (T, #FF7700) >>  {
    }
    class http.dirEntryDirs << (T, #FF7700) >>  {
    }
    class http.fileInfoDirs << (T, #FF7700) >>  {
    }
    class http.htmlSig << (T, #FF7700) >>  {
    }
    class http.http2ConnectionError << (T, #FF7700) >>  {
    }
    class http.http2ErrCode << (T, #FF7700) >>  {
    }
    class http.http2Flags << (T, #FF7700) >>  {
    }
    class http.http2FrameType << (T, #FF7700) >>  {
    }
    class http.http2SettingID << (T, #FF7700) >>  {
    }
    class http.http2WriteScheduler << (T, #FF7700) >>  {
    }
    class http.http2closeWaiter << (T, #FF7700) >>  {
    }
    class http.http2duplicatePseudoHeaderError << (T, #FF7700) >>  {
    }
    class http.http2frameParser << (T, #FF7700) >>  {
    }
    class http.http2gate << (T, #FF7700) >>  {
    }
    class http.http2goroutineLock << (T, #FF7700) >>  {
    }
    class http.http2headerFieldNameError << (T, #FF7700) >>  {
    }
    class http.http2headerFieldValueError << (T, #FF7700) >>  {
    }
    class http.http2incomparable << (T, #FF7700) >>  {
    }
    class http.http2priorityNodeState << (T, #FF7700) >>  {
    }
    class http.http2pseudoHeaderError << (T, #FF7700) >>  {
    }
    class http.http2serverMessage << (T, #FF7700) >>  {
    }
    class http.http2sortPriorityNodeSiblings << (T, #FF7700) >>  {
    }
    class http.http2streamState << (T, #FF7700) >>  {
    }
    class http.http2writeQueuePool << (T, #FF7700) >>  {
    }
    class http.http2writeSettings << (T, #FF7700) >>  {
    }
    class http.incomparable << (T, #FF7700) >>  {
    }
    class http.socksAuthMethod << (T, #FF7700) >>  {
    }
    class http.socksCommand << (T, #FF7700) >>  {
    }
    class http.socksReply << (T, #FF7700) >>  {
    }
    class http2ClientConn << (S,Aquamarine) >> {
        + SetDoNotReuse() 
        + CanTakeNewRequest() bool
        + ReserveNewRequest() bool
        + State() http2ClientConnState
        + Shutdown(ctx context.Context) error
        + Close() error
        + RoundTrip(req *Request) (*Response, error)
        + Ping(ctx context.Context) error

    }
    interface http2ClientConnPool  {
        + GetClientConn(req *Request, addr string) (*http2ClientConn, error)
        + MarkDead( *http2ClientConn) 

    }
    class http2ClientConnState << (S,Aquamarine) >> {
        + Closed bool
        + Closing bool
        + StreamsActive int
        + StreamsReserved int
        + StreamsPending int
        + MaxConcurrentStreams uint32
        + LastIdle time.Time

    }
    class http2ConnectionError << (S,Aquamarine) >> {
        + Error() string

    }
    class http2ContinuationFrame << (S,Aquamarine) >> {
        + HeaderBlockFragment() []byte
        + HeadersEnded() bool

    }
    class http2DataFrame << (S,Aquamarine) >> {
        + StreamEnded() bool
        + Data() []byte

    }
    class http2ErrCode << (S,Aquamarine) >> {
        + String() string

    }
    class http2Flags << (S,Aquamarine) >> {
        + Has(v http2Flags) bool

    }
    interface http2Frame  {
        + Header() http2FrameHeader

    }
    class http2FrameHeader << (S,Aquamarine) >> {
        + Type http2FrameType
        + Flags http2Flags
        + Length uint32
        + StreamID uint32

        + Header() http2FrameHeader
        + String() string

    }
    class http2FrameType << (S,Aquamarine) >> {
        + String() string

    }
    class http2FrameWriteRequest << (S,Aquamarine) >> {
        + StreamID() uint32
        + DataSize() int
        + Consume(n int32) (http2FrameWriteRequest, http2FrameWriteRequest, int)
        + String() string

    }
    class http2Framer << (S,Aquamarine) >> {
        + AllowIllegalWrites bool
        + AllowIllegalReads bool
        + ReadMetaHeaders *hpack.Decoder
        + MaxHeaderListSize uint32

        + SetReuseFrames() 
        + SetMaxReadFrameSize(v uint32) 
        + ErrorDetail() error
        + ReadFrame() (http2Frame, error)
        + WriteData(streamID uint32, endStream bool, data []byte) error
        + WriteDataPadded(streamID uint32, endStream bool, data []byte, pad []byte) error
        + WriteSettings(settings ...http2Setting) error
        + WriteSettingsAck() error
        + WritePing(ack bool, data []byte) error
        + WriteGoAway(maxStreamID uint32, code http2ErrCode, debugData []byte) error
        + WriteWindowUpdate(streamID uint32, incr uint32) error
        + WriteHeaders(p http2HeadersFrameParam) error
        + WritePriority(streamID uint32, p http2PriorityParam) error
        + WriteRSTStream(streamID uint32, code http2ErrCode) error
        + WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error
        + WritePushPromise(p http2PushPromiseParam) error
        + WriteRawFrame(t http2FrameType, flags http2Flags, streamID uint32, payload []byte) error

    }
    class http2GoAwayError << (S,Aquamarine) >> {
        + LastStreamID uint32
        + ErrCode http2ErrCode
        + DebugData string

        + Error() string

    }
    class http2GoAwayFrame << (S,Aquamarine) >> {
        + LastStreamID uint32
        + ErrCode http2ErrCode

        + DebugData() []byte

    }
    class http2HeadersFrame << (S,Aquamarine) >> {
        + Priority http2PriorityParam

        + HeaderBlockFragment() []byte
        + HeadersEnded() bool
        + StreamEnded() bool
        + HasPriority() bool

    }
    class http2HeadersFrameParam << (S,Aquamarine) >> {
        + StreamID uint32
        + BlockFragment []byte
        + EndStream bool
        + EndHeaders bool
        + PadLength uint8
        + Priority http2PriorityParam

    }
    class http2MetaHeadersFrame << (S,Aquamarine) >> {
        + Fields []hpack.HeaderField
        + Truncated bool

        + PseudoValue(pseudo string) string
        + RegularFields() []hpack.HeaderField
        + PseudoFields() []hpack.HeaderField

    }
    class http2OpenStreamOptions << (S,Aquamarine) >> {
        + PusherID uint32

    }
    class http2PingFrame << (S,Aquamarine) >> {
        + Data []byte

        + IsAck() bool

    }
    class http2PriorityFrame << (S,Aquamarine) >> {
    }
    class http2PriorityParam << (S,Aquamarine) >> {
        + StreamDep uint32
        + Exclusive bool
        + Weight uint8

        + IsZero() bool

    }
    class http2PriorityWriteSchedulerConfig << (S,Aquamarine) >> {
        + MaxClosedNodesInTree int
        + MaxIdleNodesInTree int
        + ThrottleOutOfOrderWrites bool

    }
    class http2PushPromiseFrame << (S,Aquamarine) >> {
        + PromiseID uint32

        + HeaderBlockFragment() []byte
        + HeadersEnded() bool

    }
    class http2PushPromiseParam << (S,Aquamarine) >> {
        + StreamID uint32
        + PromiseID uint32
        + BlockFragment []byte
        + EndHeaders bool
        + PadLength uint8

    }
    class http2RSTStreamFrame << (S,Aquamarine) >> {
        + ErrCode http2ErrCode

    }
    class http2RoundTripOpt << (S,Aquamarine) >> {
        + OnlyCachedConn bool

    }
    class http2ServeConnOpts << (S,Aquamarine) >> {
        + Context context.Context
        + BaseConfig *Server
        + Handler Handler

    }
    class http2Server << (S,Aquamarine) >> {
        + MaxHandlers int
        + MaxConcurrentStreams uint32
        + MaxReadFrameSize uint32
        + PermitProhibitedCipherSuites bool
        + IdleTimeout time.Duration
        + MaxUploadBufferPerConnection int32
        + MaxUploadBufferPerStream int32
        + NewWriteScheduler <font color=blue>func</font>() http2WriteScheduler
        + CountError <font color=blue>func</font>(string) 
        + NewWriteScheduler <font color=blue>func</font>() http2WriteScheduler

        + ServeConn(c net.Conn, opts *http2ServeConnOpts) 

    }
    class http2Setting << (S,Aquamarine) >> {
        + ID http2SettingID
        + Val uint32

        + String() string
        + Valid() error

    }
    class http2SettingID << (S,Aquamarine) >> {
        + String() string

    }
    class http2SettingsFrame << (S,Aquamarine) >> {
        + IsAck() bool
        + Value(id http2SettingID) (uint32, bool)
        + Setting(i int) http2Setting
        + NumSettings() int
        + HasDuplicates() bool
        + ForeachSetting(fn <font color=blue>func</font>(http2Setting) error) error

    }
    class http2StreamError << (S,Aquamarine) >> {
        + StreamID uint32
        + Code http2ErrCode
        + Cause error

        + Error() string

    }
    class http2Transport << (S,Aquamarine) >> {
        + DialTLS <font color=blue>func</font>(string, string, *tls.Config) (net.Conn, error)
        + TLSClientConfig *tls.Config
        + ConnPool http2ClientConnPool
        + DisableCompression bool
        + AllowHTTP bool
        + MaxHeaderListSize uint32
        + StrictMaxConcurrentStreams bool
        + ReadIdleTimeout time.Duration
        + PingTimeout time.Duration
        + WriteByteTimeout time.Duration
        + CountError <font color=blue>func</font>(string) 
        + MaxHeaderListSize uint32
        + ConnPool any

        + RoundTrip(req *Request) (*Response, error)
        + RoundTripOpt(req *Request, opt http2RoundTripOpt) (*Response, error)
        + CloseIdleConnections() 
        + NewClientConn(c net.Conn) (*http2ClientConn, error)
        + RoundTrip( *Request) (*Response, error)
        + CloseIdleConnections() 

    }
    class http2UnknownFrame << (S,Aquamarine) >> {
        + Payload() []byte

    }
    class http2WindowUpdateFrame << (S,Aquamarine) >> {
        + Increment uint32

    }
    interface http2WriteScheduler  {
        + OpenStream(streamID uint32, options http2OpenStreamOptions) 
        + CloseStream(streamID uint32) 
        + AdjustStream(streamID uint32, priority http2PriorityParam) 
        + Push(wr http2FrameWriteRequest) 
        + Pop() (http2FrameWriteRequest, bool)

    }
    class http2addConnCall << (S,Aquamarine) >> {
        + _ http2incomparable

    }
    class http2bodyReadMsg << (S,Aquamarine) >> {
    }
    class http2bufferedWriter << (S,Aquamarine) >> {
        + _ http2incomparable

        + Available() int
        + Write(p []byte) (int, error)
        + Flush() error

    }
    class http2chunkWriter << (S,Aquamarine) >> {
        + Write(p []byte) (int, error)

    }
    class http2clientConnIdleState << (S,Aquamarine) >> {
    }
    class http2clientConnPool << (S,Aquamarine) >> {
        + GetClientConn(req *Request, addr string) (*http2ClientConn, error)
        + MarkDead(cc *http2ClientConn) 

    }
    interface http2clientConnPoolIdleCloser  {
    }
    class http2clientConnReadLoop << (S,Aquamarine) >> {
        + _ http2incomparable

    }
    class http2clientStream << (S,Aquamarine) >> {
        + ID uint32

    }
    class http2closeWaiter << (S,Aquamarine) >> {
        + Init() 
        + Close() 
        + Wait() 

    }
    class http2connError << (S,Aquamarine) >> {
        + Code http2ErrCode
        + Reason string

        + Error() string

    }
    interface http2connectionStater  {
        + ConnectionState() tls.ConnectionState

    }
    class http2dataBuffer << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)
        + Len() int
        + Write(p []byte) (int, error)

    }
    class http2dialCall << (S,Aquamarine) >> {
        + _ http2incomparable

    }
    class http2duplicatePseudoHeaderError << (S,Aquamarine) >> {
        + Error() string

    }
    class http2erringRoundTripper << (S,Aquamarine) >> {
        + RoundTripErr() error
        + RoundTrip( *Request) (*Response, error)

    }
    class http2errorReader << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)

    }
    class http2flow << (S,Aquamarine) >> {
        + _ http2incomparable

    }
    class http2flushFrameWriter << (S,Aquamarine) >> {
    }
    class http2frameCache << (S,Aquamarine) >> {
    }
    class http2frameWriteResult << (S,Aquamarine) >> {
        + _ http2incomparable

    }
    class http2gate << (S,Aquamarine) >> {
        + Done() 
        + Wait() 

    }
    class http2goAwayFlowError << (S,Aquamarine) >> {
        + Error() string

    }
    class http2goroutineLock << (S,Aquamarine) >> {
    }
    class http2gzipReader << (S,Aquamarine) >> {
        + _ http2incomparable

        + Read(p []byte) (int, error)
        + Close() error

    }
    class http2handlerPanicRST << (S,Aquamarine) >> {
        + StreamID uint32

    }
    class http2headerFieldNameError << (S,Aquamarine) >> {
        + Error() string

    }
    class http2headerFieldValueError << (S,Aquamarine) >> {
        + Error() string

    }
    interface http2headersEnder  {
        + HeadersEnded() bool

    }
    interface http2headersOrContinuation  {
        + HeaderBlockFragment() []byte

    }
    class http2httpError << (S,Aquamarine) >> {
        + _ http2incomparable

        + Error() string
        + Timeout() bool
        + Temporary() bool

    }
    class http2missingBody << (S,Aquamarine) >> {
        + Close() error
        + Read( []byte) (int, error)

    }
    class http2noCachedConnError << (S,Aquamarine) >> {
        + IsHTTP2NoCachedConnError() 
        + Error() string
        + IsHTTP2NoCachedConnError() 
        + Error() string

    }
    class http2noDialClientConnPool << (S,Aquamarine) >> {
        + GetClientConn(req *Request, addr string) (*http2ClientConn, error)

    }
    class http2noDialH2RoundTripper << (S,Aquamarine) >> {
        + RoundTrip(req *Request) (*Response, error)
        + RoundTrip( *Request) (*Response, error)

    }
    class http2pipe << (S,Aquamarine) >> {
        + Len() int
        + Read(d []byte) (int, error)
        + Write(d []byte) (int, error)
        + CloseWithError(err error) 
        + BreakWithError(err error) 
        + Err() error
        + Done() <font color=blue>chan</font> <font color=blue>struct</font>{}

    }
    interface http2pipeBuffer  {
        + Len() int

    }
    class http2priorityNode << (S,Aquamarine) >> {
    }
    class http2priorityWriteScheduler << (S,Aquamarine) >> {
        + OpenStream(streamID uint32, options http2OpenStreamOptions) 
        + CloseStream(streamID uint32) 
        + AdjustStream(streamID uint32, priority http2PriorityParam) 
        + Push(wr http2FrameWriteRequest) 
        + Pop() (http2FrameWriteRequest, bool)

    }
    class http2pseudoHeaderError << (S,Aquamarine) >> {
        + Error() string

    }
    class http2randomWriteScheduler << (S,Aquamarine) >> {
        + OpenStream(streamID uint32, options http2OpenStreamOptions) 
        + CloseStream(streamID uint32) 
        + AdjustStream(streamID uint32, priority http2PriorityParam) 
        + Push(wr http2FrameWriteRequest) 
        + Pop() (http2FrameWriteRequest, bool)

    }
    class http2readFrameResult << (S,Aquamarine) >> {
    }
    class http2requestBody << (S,Aquamarine) >> {
        + _ http2incomparable

        + Close() error
        + Read(p []byte) (int, error)

    }
    class http2requestParam << (S,Aquamarine) >> {
    }
    class http2resAndError << (S,Aquamarine) >> {
        + _ http2incomparable

    }
    class http2responseWriter << (S,Aquamarine) >> {
        + Flush() 
        + CloseNotify() <font color=blue>chan</font> bool
        + Header() Header
        + WriteHeader(code int) 
        + Write(p []byte) (int, error)
        + WriteString(s string) (int, error)
        + Push(target string, opts *PushOptions) error

    }
    class http2responseWriterState << (S,Aquamarine) >> {
    }
    class http2serverConn << (S,Aquamarine) >> {
        + Framer() *http2Framer
        + CloseConn() error
        + Flush() error
        + HeaderEncoder() (*hpack.Encoder, *bytes.Buffer)

    }
    class http2serverInternalState << (S,Aquamarine) >> {
    }
    class http2sortPriorityNodeSiblings << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, k int) 
        + Less(i int, k int) bool

    }
    class http2sorter << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool
        + Keys(h Header) []string
        + SortStrings(ss []string) 

    }
    class http2startPushRequest << (S,Aquamarine) >> {
    }
    class http2stickyErrWriter << (S,Aquamarine) >> {
        + Write(p []byte) (int, error)

    }
    class http2stream << (S,Aquamarine) >> {
    }
    interface http2streamEnder  {
        + StreamEnded() bool

    }
    class http2streamState << (S,Aquamarine) >> {
        + String() string

    }
    interface http2stringWriter  {
        + WriteString(s string) (int, error)

    }
    class http2transportResponseBody << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)
        + Close() error

    }
    class http2write100ContinueHeadersFrame << (S,Aquamarine) >> {
    }
    interface http2writeContext  {
        + Framer() *http2Framer
        + Flush() error
        + CloseConn() error
        + HeaderEncoder() (*hpack.Encoder, *bytes.Buffer)

    }
    class http2writeData << (S,Aquamarine) >> {
        + String() string

    }
    interface http2writeFramer  {
    }
    class http2writeGoAway << (S,Aquamarine) >> {
    }
    class http2writePingAck << (S,Aquamarine) >> {
    }
    class http2writePushPromise << (S,Aquamarine) >> {
    }
    class http2writeQueue << (S,Aquamarine) >> {
    }
    class http2writeQueuePool << (S,Aquamarine) >> {
    }
    class http2writeResHeaders << (S,Aquamarine) >> {
    }
    class http2writeSettings << (S,Aquamarine) >> {
    }
    class http2writeSettingsAck << (S,Aquamarine) >> {
    }
    class http2writeWindowUpdate << (S,Aquamarine) >> {
    }
    class httpError << (S,Aquamarine) >> {
        + Error() string
        + Timeout() bool
        + Temporary() bool

    }
    class httpRange << (S,Aquamarine) >> {
    }
    class initALPNRequest << (S,Aquamarine) >> {
        + BaseContext() context.Context
        + ServeHTTP(rw ResponseWriter, req *Request) 

    }
    class ioFS << (S,Aquamarine) >> {
        + Open(name string) (File, error)

    }
    class ioFile << (S,Aquamarine) >> {
        + Close() error
        + Read(b []byte) (int, error)
        + Stat() (fs.FileInfo, error)
        + Seek(offset int64, whence int) (int64, error)
        + ReadDir(count int) ([]fs.DirEntry, error)
        + Readdir(count int) ([]fs.FileInfo, error)

    }
    class keyValues << (S,Aquamarine) >> {
    }
    class loggingConn << (S,Aquamarine) >> {
        + Write(p []byte) (int, error)
        + Read(p []byte) (int, error)
        + Close() error

    }
    class maskedSig << (S,Aquamarine) >> {
    }
    class maxBytesReader << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)
        + Close() error

    }
    class mp4Sig << (S,Aquamarine) >> {
    }
    class muxEntry << (S,Aquamarine) >> {
    }
    class noBody << (S,Aquamarine) >> {
        + Read( []byte) (int, error)
        + Close() error
        + WriteTo( io.Writer) (int64, error)

    }
    class nothingWrittenError << (S,Aquamarine) >> {
    }
    class onceCloseListener << (S,Aquamarine) >> {
        + Close() error

    }
    class persistConn << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)

    }
    class persistConnWriter << (S,Aquamarine) >> {
        + Write(p []byte) (int, error)
        + ReadFrom(r io.Reader) (int64, error)

    }
    class populateResponse << (S,Aquamarine) >> {
        + Header() Header
        + WriteHeader(code int) 
        + Write(p []byte) (int, error)

    }
    class readResult << (S,Aquamarine) >> {
        + _ incomparable

    }
    class readTrackingBody << (S,Aquamarine) >> {
        + Read(data []byte) (int, error)
        + Close() error

    }
    class readWriteCloserBody << (S,Aquamarine) >> {
        + _ incomparable

        + Read(p []byte) (int, error)

    }
    class redirectHandler << (S,Aquamarine) >> {
        + ServeHTTP(w ResponseWriter, r *Request) 

    }
    class requestAndChan << (S,Aquamarine) >> {
        + _ incomparable

    }
    class requestBodyReadError << (S,Aquamarine) >> {
    }
    class response << (S,Aquamarine) >> {
        + ReadFrom(src io.Reader) (int64, error)
        + Header() Header
        + WriteHeader(code int) 
        + Write(data []byte) (int, error)
        + WriteString(data string) (int, error)
        + Flush() 
        + Hijack() (net.Conn, *bufio.ReadWriter, error)
        + CloseNotify() <font color=blue>chan</font> bool

    }
    class responseAndError << (S,Aquamarine) >> {
        + _ incomparable

    }
    class serverHandler << (S,Aquamarine) >> {
        + ServeHTTP(rw ResponseWriter, req *Request) 

    }
    interface sniffSig  {
    }
    class socksAddr << (S,Aquamarine) >> {
        + Name string
        + IP net.IP
        + Port int

        + Network() string
        + String() string

    }
    class socksCommand << (S,Aquamarine) >> {
        + String() string

    }
    class socksConn << (S,Aquamarine) >> {
        + BoundAddr() net.Addr

    }
    class socksDialer << (S,Aquamarine) >> {
        + ProxyDial <font color=blue>func</font>(context.Context, string, string) (net.Conn, error)
        + AuthMethods []socksAuthMethod
        + Authenticate <font color=blue>func</font>(context.Context, io.ReadWriter, socksAuthMethod) error

        + DialContext(ctx context.Context, network string, address string) (net.Conn, error)
        + DialWithConn(ctx context.Context, c net.Conn, network string, address string) (net.Addr, error)
        + Dial(network string, address string) (net.Conn, error)

    }
    class socksReply << (S,Aquamarine) >> {
        + String() string

    }
    class socksUsernamePassword << (S,Aquamarine) >> {
        + Username string
        + Password string

        + Authenticate(ctx context.Context, rw io.ReadWriter, auth socksAuthMethod) error

    }
    class statusError << (S,Aquamarine) >> {
        + Error() string

    }
    class streamReader << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)
        + Close() error

    }
    class stringWriter << (S,Aquamarine) >> {
        + WriteString(s string) (int, error)

    }
    class tLogKey << (S,Aquamarine) >> {
    }
    class textSig << (S,Aquamarine) >> {
    }
    class timeoutHandler << (S,Aquamarine) >> {
        + ServeHTTP(w ResponseWriter, r *Request) 

    }
    class timeoutWriter << (S,Aquamarine) >> {
        + Push(target string, opts *PushOptions) error
        + Header() Header
        + Write(p []byte) (int, error)
        + WriteHeader(code int) 

    }
    class tlsHandshakeTimeoutError << (S,Aquamarine) >> {
        + Timeout() bool
        + Temporary() bool
        + Error() string

    }
    class transferReader << (S,Aquamarine) >> {
        + Header Header
        + StatusCode int
        + RequestMethod string
        + ProtoMajor int
        + ProtoMinor int
        + Body io.ReadCloser
        + ContentLength int64
        + Chunked bool
        + Close bool
        + Trailer Header

    }
    class transferWriter << (S,Aquamarine) >> {
        + Method string
        + Body io.Reader
        + BodyCloser io.Closer
        + ResponseToHEAD bool
        + ContentLength int64
        + Close bool
        + TransferEncoding []string
        + Header Header
        + Trailer Header
        + IsResponse bool
        + FlushHeaders bool
        + ByteReadCh <font color=blue>chan</font> readResult

    }
    class transportReadFromServerError << (S,Aquamarine) >> {
        + Unwrap() error
        + Error() string

    }
    class transportRequest << (S,Aquamarine) >> {
    }
    class unsupportedTEError << (S,Aquamarine) >> {
        + Error() string

    }
    class wantConn << (S,Aquamarine) >> {
    }
    class wantConnQueue << (S,Aquamarine) >> {
    }
    class writeRequest << (S,Aquamarine) >> {
    }
    class writerOnly << (S,Aquamarine) >> {
    }
    class "[]fs.DirEntry" as fsDirEntry {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "[]fs.FileInfo" as fsFileInfo {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"http.http2FrameHeader" *-- "http.http2ContinuationFrame"
"http.http2FrameHeader" *-- "http.http2DataFrame"
"http.http2FrameHeader" *-- "http.http2GoAwayFrame"
"http.http2FrameHeader" *-- "http.http2HeadersFrame"
"http.http2HeadersFrame" *-- "http.http2MetaHeadersFrame"
"http.http2FrameHeader" *-- "http.http2PingFrame"
"http.http2FrameHeader" *-- "http.http2PriorityFrame"
"http.http2PriorityParam" *-- "http.http2PriorityFrame"
"http.http2FrameHeader" *-- "http.http2PushPromiseFrame"
"http.http2FrameHeader" *-- "http.http2RSTStreamFrame"
"http.http2FrameHeader" *-- "http.http2SettingsFrame"
"http.http2FrameHeader" *-- "http.http2UnknownFrame"
"http.http2FrameHeader" *-- "http.http2WindowUpdateFrame"
"http.http2ClientConnPool" *-- "http.http2clientConnPoolIdleCloser"
"http.http2headersEnder" *-- "http.http2headersOrContinuation"
"http.http2clientConnPool" *-- "http.http2noDialClientConnPool"
"http.http2Transport" *-- "http.http2noDialH2RoundTripper"
"net.Conn" *-- "http.loggingConn"
"__builtin__.error" *-- "http.nothingWrittenError"
"net.Listener" *-- "http.onceCloseListener"
"io.ReadCloser" *-- "http.readTrackingBody"
"io.ReadWriteCloser" *-- "http.readWriteCloserBody"
"__builtin__.error" *-- "http.requestBodyReadError"
"net.Conn" *-- "http.socksConn"
"http.Request" *-- "http.transportRequest"
"io.Writer" *-- "http.writerOnly"

"http.h2Transport" <|-- "http.Client"
"httptest.closeIdleTransport" <|-- "http.Client"
"http.FileSystem" <|-- "http.Dir"
"http.Handler" <|-- "http.HandlerFunc"
"http.Handler" <|-- "http.ServeMux"
"http.RoundTripper" <|-- "http.Transport"
"http.h2Transport" <|-- "http.Transport"
"httptest.closeIdleTransport" <|-- "http.Transport"
"http.anyDirs" <|-- "http.dirEntryDirs"
"http.sniffSig" <|-- "http.exactSig"
"http.Handler" <|-- "http.fileHandler"
"http.anyDirs" <|-- "http.fileInfoDirs"
"http.RoundTripper" <|-- "http.fileTransport"
"http.Handler" <|-- "http.globalOptionsHandler"
"http.http2pipeBuffer" <|-- "http.headerSorter"
"http.sniffSig" <|-- "http.htmlSig"
"http.RoundTripper" <|-- "http.http2ClientConn"
"http.http2headersEnder" <|-- "http.http2ContinuationFrame"
"http.http2headersOrContinuation" <|-- "http.http2ContinuationFrame"
"http.http2streamEnder" <|-- "http.http2DataFrame"
"http.http2Frame" <|-- "http.http2FrameHeader"
"http.http2headersEnder" <|-- "http.http2HeadersFrame"
"http.http2headersOrContinuation" <|-- "http.http2HeadersFrame"
"http.http2streamEnder" <|-- "http.http2HeadersFrame"
"http.http2headersEnder" <|-- "http.http2PushPromiseFrame"
"http.http2headersOrContinuation" <|-- "http.http2PushPromiseFrame"
"http.http2writeFramer" <|-- "http.http2StreamError"
"http.RoundTripper" <|-- "http.http2Transport"
"http.h2Transport" <|-- "http.http2Transport"
"httptest.closeIdleTransport" <|-- "http.http2Transport"
"http.http2ClientConnPool" <|-- "http.http2clientConnPool"
"http.http2clientConnPoolIdleCloser" <|-- "http.http2clientConnPool"
"http.http2pipeBuffer" <|-- "http.http2dataBuffer"
"http.RoundTripper" <|-- "http.http2erringRoundTripper"
"http.erringRoundTripper" <|-- "http.http2erringRoundTripper"
"http.http2writeFramer" <|-- "http.http2flushFrameWriter"
"http.http2writeFramer" <|-- "http.http2handlerPanicRST"
"http.RoundTripper" <|-- "http.http2noDialH2RoundTripper"
"http.http2pipeBuffer" <|-- "http.http2pipe"
"http.http2WriteScheduler" <|-- "http.http2priorityWriteScheduler"
"http.http2WriteScheduler" <|-- "http.http2randomWriteScheduler"
"http.CloseNotifier" <|-- "http.http2responseWriter"
"http.Flusher" <|-- "http.http2responseWriter"
"http.Pusher" <|-- "http.http2responseWriter"
"http.ResponseWriter" <|-- "http.http2responseWriter"
"http.http2stringWriter" <|-- "http.http2responseWriter"
"http.http2writeContext" <|-- "http.http2serverConn"
"http.http2pipeBuffer" <|-- "http.http2sortPriorityNodeSiblings"
"http.http2pipeBuffer" <|-- "http.http2sorter"
"http.http2writeFramer" <|-- "http.http2write100ContinueHeadersFrame"
"http.http2writeFramer" <|-- "http.http2writeData"
"http.http2writeFramer" <|-- "http.http2writeGoAway"
"http.http2writeFramer" <|-- "http.http2writePingAck"
"http.http2writeFramer" <|-- "http.http2writePushPromise"
"http.http2writeFramer" <|-- "http.http2writeResHeaders"
"http.http2writeFramer" <|-- "http.http2writeSettings"
"http.http2writeFramer" <|-- "http.http2writeSettingsAck"
"http.http2writeFramer" <|-- "http.http2writeWindowUpdate"
"http.Handler" <|-- "http.initALPNRequest"
"http.FileSystem" <|-- "http.ioFS"
"http.File" <|-- "http.ioFile"
"http.sniffSig" <|-- "http.maskedSig"
"http.sniffSig" <|-- "http.mp4Sig"
"http.ResponseWriter" <|-- "http.populateResponse"
"http.Handler" <|-- "http.redirectHandler"
"http.CloseNotifier" <|-- "http.response"
"http.Flusher" <|-- "http.response"
"http.Hijacker" <|-- "http.response"
"http.ResponseWriter" <|-- "http.response"
"http.http2stringWriter" <|-- "http.response"
"http.Handler" <|-- "http.serverHandler"
"http.http2stringWriter" <|-- "http.stringWriter"
"http.sniffSig" <|-- "http.textSig"
"http.Handler" <|-- "http.timeoutHandler"
"http.Pusher" <|-- "http.timeoutWriter"
"http.ResponseWriter" <|-- "http.timeoutWriter"

namespace httptest {
    class ResponseRecorder << (S,Aquamarine) >> {
        + Code int
        + HeaderMap http.Header
        + Body *bytes.Buffer
        + Flushed bool

        + Header() http.Header
        + Write(buf []byte) (int, error)
        + WriteString(str string) (int, error)
        + WriteHeader(code int) 
        + Flush() 
        + Result() *http.Response

    }
    class Server << (S,Aquamarine) >> {
        + URL string
        + Listener net.Listener
        + EnableHTTP2 bool
        + TLS *tls.Config
        + Config *http.Server

        + Start() 
        + StartTLS() 
        + Close() 
        + CloseClientConnections() 
        + Certificate() *x509.Certificate
        + Client() *http.Client

    }
    interface closeIdleTransport  {
        + CloseIdleConnections() 

    }
}

"http.Flusher" <|-- "httptest.ResponseRecorder"
"http.ResponseWriter" <|-- "httptest.ResponseRecorder"
"http.http2stringWriter" <|-- "httptest.ResponseRecorder"

namespace httptrace {
    class ClientTrace << (S,Aquamarine) >> {
        + GetConn <font color=blue>func</font>(string) 
        + GotConn <font color=blue>func</font>(GotConnInfo) 
        + PutIdleConn <font color=blue>func</font>(error) 
        + GotFirstResponseByte <font color=blue>func</font>() 
        + Got100Continue <font color=blue>func</font>() 
        + Got1xxResponse <font color=blue>func</font>(int, textproto.MIMEHeader) error
        + DNSStart <font color=blue>func</font>(DNSStartInfo) 
        + DNSDone <font color=blue>func</font>(DNSDoneInfo) 
        + ConnectStart <font color=blue>func</font>(string, string) 
        + ConnectDone <font color=blue>func</font>(string, string, error) 
        + TLSHandshakeStart <font color=blue>func</font>() 
        + TLSHandshakeDone <font color=blue>func</font>(tls.ConnectionState, error) 
        + WroteHeaderField <font color=blue>func</font>(string, []string) 
        + WroteHeaders <font color=blue>func</font>() 
        + Wait100Continue <font color=blue>func</font>() 
        + WroteRequest <font color=blue>func</font>(WroteRequestInfo) 

    }
    class DNSDoneInfo << (S,Aquamarine) >> {
        + Addrs []net.IPAddr
        + Err error
        + Coalesced bool

    }
    class DNSStartInfo << (S,Aquamarine) >> {
        + Host string

    }
    class GotConnInfo << (S,Aquamarine) >> {
        + Conn net.Conn
        + Reused bool
        + WasIdle bool
        + IdleTime time.Duration

    }
    class WroteRequestInfo << (S,Aquamarine) >> {
        + Err error

    }
    class clientEventContextKey << (S,Aquamarine) >> {
    }
}


namespace httputil {
    interface BufferPool  {
        + Get() []byte
        + Put( []byte) 

    }
    class ClientConn << (S,Aquamarine) >> {
        + Hijack() (net.Conn, *bufio.Reader)
        + Close() error
        + Write(req *http.Request) error
        + Pending() int
        + Read(req *http.Request) (*http.Response, error)
        + Do(req *http.Request) (*http.Response, error)

    }
    class ReverseProxy << (S,Aquamarine) >> {
        + Director <font color=blue>func</font>(*http.Request) 
        + Transport http.RoundTripper
        + FlushInterval time.Duration
        + ErrorLog *log.Logger
        + BufferPool BufferPool
        + ModifyResponse <font color=blue>func</font>(*http.Response) error
        + ErrorHandler <font color=blue>func</font>(http.ResponseWriter, *http.Request, error) 

        + ServeHTTP(rw http.ResponseWriter, req *http.Request) 

    }
    class ServerConn << (S,Aquamarine) >> {
        + Hijack() (net.Conn, *bufio.Reader)
        + Close() error
        + Read() (*http.Request, error)
        + Pending() int
        + Write(req *http.Request, resp *http.Response) error

    }
    class delegateReader << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)

    }
    class dumpConn << (S,Aquamarine) >> {
        + Close() error
        + LocalAddr() net.Addr
        + RemoteAddr() net.Addr
        + SetDeadline(t time.Time) error
        + SetReadDeadline(t time.Time) error
        + SetWriteDeadline(t time.Time) error

    }
    class failureToReadBody << (S,Aquamarine) >> {
        + Read( []byte) (int, error)
        + Close() error

    }
    class httputil.neverEnding << (T, #FF7700) >>  {
    }
    class maxLatencyWriter << (S,Aquamarine) >> {
        + Write(p []byte) (int, error)

    }
    class neverEnding << (S,Aquamarine) >> {
        + Read(p []byte) (int, error)

    }
    class switchProtocolCopier << (S,Aquamarine) >> {
    }
    interface writeFlusher  {
    }
}
"io.Reader" *-- "httputil.dumpConn"
"io.Writer" *-- "httputil.dumpConn"

"http.Handler" <|-- "httputil.ReverseProxy"

namespace internal {
    class FlushAfterChunkWriter << (S,Aquamarine) >> {
    }
    class chunkedReader << (S,Aquamarine) >> {
        + Read(b []uint8) (int, error)

    }
    class chunkedWriter << (S,Aquamarine) >> {
        + Wire io.Writer

        + Write(data []byte) (int, error)
        + Close() error

    }
}
"bufio.Writer" *-- "internal.FlushAfterChunkWriter"


namespace main {
    class Chan << (S,Aquamarine) >> {
        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class Counter << (S,Aquamarine) >> {
        + String() string
        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class main.Chan << (T, #FF7700) >>  {
    }
}

"http.Handler" <|-- "main.Chan"
"http.Handler" <|-- "main.Counter"

namespace pprof {
    class handler << (S,Aquamarine) >> {
        + ServeHTTP(w http.ResponseWriter, r *http.Request) 

    }
    class pprof.handler << (T, #FF7700) >>  {
    }
    class profileEntry << (S,Aquamarine) >> {
        + Name string
        + Href string
        + Desc string
        + Count int

    }
}

"http.Handler" <|-- "pprof.handler"

"__builtin__.<font color=blue>chan</font> int" #.. "main.Chan"
"__builtin__.<font color=blue>map</font>[string][]string" #.. "http.Header"
"__builtin__.[]byte" #.. "http.htmlSig"
"__builtin__.byte" #.. "httputil.neverEnding"
"__builtin__.int" #.. "http.ConnState"
"__builtin__.int" #.. "http.SameSite"
"__builtin__.int" #.. "http.condResult"
"__builtin__.int" #.. "http.http2priorityNodeState"
"__builtin__.int" #.. "http.http2serverMessage"
"__builtin__.int" #.. "http.http2streamState"
"__builtin__.int" #.. "http.socksAuthMethod"
"__builtin__.int" #.. "http.socksCommand"
"__builtin__.int" #.. "http.socksReply"
"__builtin__.int32" #.. "http.atomicBool"
"__builtin__.int64" #.. "http.countingWriter"
"__builtin__.string" #.. "http.Dir"
"__builtin__.string" #.. "http.http2duplicatePseudoHeaderError"
"__builtin__.string" #.. "http.http2headerFieldNameError"
"__builtin__.string" #.. "http.http2headerFieldValueError"
"__builtin__.string" #.. "http.http2pseudoHeaderError"
"__builtin__.string" #.. "pprof.handler"
"__builtin__.uint16" #.. "http.http2SettingID"
"__builtin__.uint32" #.. "http.http2ErrCode"
"__builtin__.uint64" #.. "http.http2goroutineLock"
"__builtin__.uint8" #.. "fcgi.recType"
"__builtin__.uint8" #.. "http.http2Flags"
"__builtin__.uint8" #.. "http.http2FrameType"
"http.<font color=blue>chan</font> <font color=blue>struct</font>{}" #.. "http.http2closeWaiter"
"http.<font color=blue>chan</font> <font color=blue>struct</font>{}" #.. "http.http2gate"
"http.<font color=blue>func</font>(*http2frameCache, http2FrameHeader, <font color=blue>func</font>(string) , []byte) (http2Frame, error)" #.. "http.http2frameParser"
"http.<font color=blue>func</font>(ResponseWriter, *Request) " #.. "http.HandlerFunc"
"http.[]*http2priorityNode" #.. "http.http2sortPriorityNodeSiblings"
"http.[]*http2writeQueue" #.. "http.http2writeQueuePool"
"http.[]<font color=blue>func</font>() " #.. "http.http2incomparable"
"http.[]<font color=blue>func</font>() " #.. "http.incomparable"
"http.fsDirEntry" #.. "http.dirEntryDirs"
"http.fsFileInfo" #.. "http.fileInfoDirs"
"http.[]http2Setting" #.. "http.http2writeSettings"
"http.any" #.. "http.http2WriteScheduler"
"http.http2ErrCode" #.. "http.http2ConnectionError"
@enduml
